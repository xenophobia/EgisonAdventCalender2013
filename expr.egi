#| matchers |#
(define $op
  (algebraic-data-matcher
   {<eq> <lt> <le> <gt> <ge> <plus> <mult>}))

(define $expr
  (algebraic-data-matcher
    {<boolE bool>
     <intE integer>
     <varE string>
     <opE op expr expr>
     <letE string (list string) expr expr>
     <ifE expr expr expr>
     <appE string (list expr)>
     <fail>}))

(define $contains
  (pattern-function [$p] <join _ <cons p _>>))

(define $childexpr
  (pattern-function [$p]
    (| <opE _ p _> <opE _ _ p>
       <letE _ _ p _> <letE _ _ _ p>
       <ifE p _ _> <ifE _ p _> <ifE _ _ p>
       <appE _ (contains p)>)))

(define $subexpr
  (pattern-function [$p] (| (childexpr (subexpr p)) p)))

(define $value (pattern-function [] (| <boolE _> <intE _>)))
(define $leafs (pattern-function [] (| (value) <varE _>)))
(define $leafexpr
  (pattern-function [$p] (subexpr (& p (leafs)))))

#| eval |#
(define $op-eval
  (match-lambda expr
    {[<opE <eq> $v1 $v2> <BoolE (eq v1 v2)>]
     [<opE <lt> <intE $i1> <intE $i2>> <BoolE (lt $i1 $i2)>]
     [<opE <le> <intE $i1> <intE $i2>> <BoolE (le $i1 $i2)>]
     [<opE <gt> <intE $i1> <intE $i2>> <BoolE (gt $i1 $i2)>]
     [<opE <ge> <intE $i1> <intE $i2>> <BoolE (ge $i1 $i2)>]
     [<opE <plus> <intE $i1> <intE $i2>> <IntE (+ $i1 $i2)>]
     [<opE <mult> <intE $i1> <intE $i2>> <IntE (* $i1 $i2)>]
     [_ <Fail>]}))

#| instances |#

(define $factE
  <LetE "fact" {"x"}
        <IfE <OpE <Ge> <VarE "x"> <IntE 0>>
             <LetE "y" {}
                   <OpE <Plus> <VarE "x"> <IntE -1>>
                   <AppE "fact" {<VarE "y">}>>
             <IntE 1>>
        <AppE "fact" {<VarE "n">}>>)
